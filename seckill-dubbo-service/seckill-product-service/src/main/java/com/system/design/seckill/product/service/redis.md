###关于缓存一致性
1.先更新db,后删缓存；结合布隆过滤器，防止查询的时候缓存穿透
2.canal监听db,进行redis数据更新,更新的时候是否需要事务支持还是直接就存了，覆盖了


###关于缓存穿透
定义：缓存穿透是指当并发流量大时,缓存失效，大量请求打进底层数据库,把DB打垮;
    1）缓存层查询缓存未命中；
    2）或者数据库中本身存储的值为null，造成更新的redis新值仍旧命中不了；
处理方案：
1.空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），
比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。
`    public Object getObjectInclNullById(Integer id) {    
        // 从缓存中获取数据
        Object cacheValue = cache.get(id);
        // 缓存为空
        if (cacheValue != null) {
            // 从数据库中获取
            Object storageValue = storage.get(key);
            // 缓存空对象
            cache.set(key, storageValue);
            // 如果存储数据为空，需要设置一个过期时间(300秒)
            if (storageValue == null) {
                // 必须设置过期时间，否则有被攻击的风险
                cache.expire(key, 60 * 5);
            }
            return storageValue;
        }
        return cacheValue;
    }`
   
2.1互斥锁   
思想：在缓存失效的时候（判断拿出来的值为空），不是立即去load db，
而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，
当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法
 `public String get(key) {
       String value = redis.get(key);
       if (value == null) { //代表缓存值过期
           //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
            if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
                value = db.get(key);
                redis.set(key, value, expire_secs);
                redis.del(key_mutex);
            } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                sleep(50);
                get(key);  //重试
            }
       } else {
           return value;      
       }
  }` 
  
  加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！
  注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！
    
3.布隆过滤器
概念：
布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为 O(n),O(log n),O(n/k)
布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。
  
设置过期时间，让其自动过期失效，这种在很多时候不是最佳的实践方案。
 我们可以提前将真实正确的商品Id，在添加完成之后便加入到过滤器当中，每次再进行查询时，先确认要查询的Id是否在过滤器当中，
 如果不在，则说明Id为非法Id，则不需要进行后续的查询步骤了。
`public Object getObjectByBloom(Integer id) {
    // 判断是否为合法id
    if (!bloomFilter.mightContain(id)) {
        // 非法id,则不允许继续查库
        return null;
    } else {
        // 从缓存中获取数据
        Object cacheValue = cache.get(id);
        // 缓存为空
        if (cacheValue == null) {
            //？？？？？？？？？？？下面两步骤是否可以加入互斥锁的思想，保证只有一个线程去查db,并更新缓存
            // 从数据库中获取
            Object storageValue = storage.get(id);
            // 缓存空对象
            cache.set(id, storageValue);
        }
        return cacheValue;
    }
} `


###关于缓存雪崩
描述：
`缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。`
解决方案：
`缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
设置热点数据永远不过期。 `